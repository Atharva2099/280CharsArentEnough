{"pageProps":{"posts":[{"slug":"Getting Started with Trip AI Your LLM Powered Travel Companion","title":"Getting Started with Trip AI Your LLM Powered Travel Companion","date":"2025-01-10","categories":["React","LLM"],"image":"/images/trip1.png","summary":"Read this post to learn more...","content":"\n## Overview\nTrip AI harnesses the power of Large Language Models to transform your travel planning experience. Whether you're planning a weekend getaway or a two-week adventure, Trip AI helps you create detailed, personalized itineraries with just a few clicks. In this guide, we'll explore how to use Trip AI and make the most of its features.\n\n## Problem and Motivation\nTraditional travel planning often involves juggling multiple tabs, cross-referencing reviews, and manually organizing schedules. Trip AI streamlines this process by leveraging LLMs to generate comprehensive itineraries while giving you full control over the details. The best part? You can try it right now at [Trip AI](https://atharva2099.github.io/Trip.AI/).\n\n## Getting Started\n\n### 1. Setting Up Access\nThere are two ways to get started with Trip AI:\n\n#### Direct Usage\n1. Visit [Trip AI](https://atharva2099.github.io/Trip.AI/)\n2. Get a free Groq API key from [Groq Console](https://console.groq.com/keys)\n3. Enter your API key when prompted (stored locally in your browser)\n\n#### Local Development\n```bash\n\n# Clone the repository\ngit clone https://github.com/Atharva2099/Trip.AI.git\ncd Trip AI\n\n# Install dependencies\nnpm install\n\n# Add your Groq API key to .env file\necho \"REACT_APP_GROQ_API_KEY=your_key_here\" > .env\n\n# Start the development server\nnpm start\n\n```\n\n### 2. Creating Your First Itinerary\nThe process is straightforward:\n\n1. Enter your destination\n2. Select travel dates\n3. Set your budget\n4. Specify number of travelers\n5. Add interests (optional)\n6. Click \"Generate Itinerary\"\n\n### 3. Smart Features\n\n#### Real-Time Fact Checking\nTrip AI validates every location and activity it suggests:\n- Confirms actual existence of locations\n- Verifies distances between activities\n- Checks opening hours and accessibility\n- Validates price ranges against real-world data\n\n#### Interactive Customization\nDon't like a suggested activity? No problem! Every element of your itinerary is customizable:\n- Click on any activity or meal to open the modification chat\n- Ask for alternatives, adjust timing, or request different price points\n- The LLM ensures all changes maintain consistency with your overall plan\n- Get instant suggestions that account for location, budget, and timing constraints\n\n#### Smart Map Integration\n- Interactive map shows your daily route\n- Click markers for activity details\n- Get real-time directions to any location\n- Visualize travel times between activities\n\n## Pro Tips\n\n1. **Budget Optimization**\n   - Start with a slightly lower budget than your maximum\n   - Use the modification feature to upgrade specific activities you care about\n   - The cost breakdown helps you track spending across categories\n\n2. **Customization Tricks**\n   ```text\n   \n   Some effective modification requests:\n   - \"Find a cheaper alternative to this activity\"\n   - \"Suggest a more local restaurant instead\"\n   - \"Move this activity to earlier in the day\"\n   - \"Find something more kid-friendly\"\n   \n   ```\n\n3. **Location Management**\n   - Trip AI automatically optimizes routes\n   - Use the map view to ensure distances are comfortable\n   - Request changes if locations seem too far apart\n\n## Future Improvements\nWe're constantly working to enhance Trip AI with features like:\n- Multi-city trip planning\n- Integrated travel booking\n- Group collaboration tools\n- Local events integration\n- Offline mode support\n\n## Conclusion\nTrip AI demonstrates how LLMs can transform travel planning from a chore into an enjoyable experience. Whether you use the hosted version or run it locally, the combination of intelligent suggestions and real-time customization helps create the perfect itinerary for your needs.\n\nWant to contribute or suggest features? Check out our [GitHub repository](https://github.com/Atharva2099/Trip.AI)!\n\n---\nGitHub: [@FullMLAlchemist](https://github.com/Atharva2099)\nTwitter: [@Attharave](https://x.com/attharave)\n"},{"slug":"Monte Carlo Simulation For N Queens Problem","title":"Monte Carlo Simulation For N Queens Problem","date":"2024-11-28","categories":["Monte Carlo","BackTracking","N-Queens","Statistics","visualisation"],"image":"/images/monte-carlo-simulation-for-n-queens-problem.png","summary":"Read this post to learn more...","content":"\n## Introduction\nThe N-Queens problem is a classic chess puzzle where we need to place N queens on an NÃ—N chessboard such that no two queens threaten each other. A Monte Carlo simulation can help us estimate the complexity of solving this problem using backtracking.\n\n## Concept: Monte Carlo Method\nMonte Carlo methods use random sampling to obtain numerical results. In our case, we:\n1. Randomly explore paths in the state space tree\n2. Count nodes visited and promising positions\n3. Estimate total complexity through multiple trials\n\n## Setup and Dependencies\n```python\n\nimport random\nimport time\nfrom statistics import mean, stdev\nimport numpy as np\n\n```\n\n## Core Function: Checking Promising Positions\nWe need to determine if a queen placement is valid (promising) by checking:\n- No queen in the same column\n- No queen in the diagonals\n\n```python\n\ndef promising(i, j, col):\n    \"\"\"Check if placing a queen at position (i,j) is promising\"\"\"\n    for k in range(i):\n        if (col[k] == j or abs(col[k] - j) == abs(k - i)):\n            return False\n    return True\n\n```\n\n## Monte Carlo Estimation\nThe estimation process:\n1. Start from root node\n2. At each level:\n   - Count total nodes\n   - Find promising positions\n   - Randomly select one promising child\n3. Continue until no promising children or board is full\n\n```python\n\ndef monte_carlo_estimate(n):\n    \"\"\"\n    Perform one Monte Carlo estimation for n-Queens problem\n    Returns tuple of (total_nodes, promising_nodes)\n    \"\"\"\n    col = [-1] * n\n    total_nodes = 1    # Root node\n    promising_nodes = 1  # Root is promising\n    m = 1\n    mprod = 1\n    i = 0\n    \n    while m != 0 and i != n:\n        mprod = mprod * m\n        current_level_nodes = mprod * n\n        total_nodes += current_level_nodes\n        \n        # Find promising children at current level\n        m = 0\n        prom_children = []\n        for j in range(n):\n            if promising(i, j, col):\n                m += 1\n                prom_children.append(j)\n        \n        promising_nodes += m * mprod\n        \n        if m != 0:\n            j = random.choice(prom_children)\n            col[i] = j\n            i += 1\n    \n    return (total_nodes, promising_nodes)\n\n```\n\n## Running Multiple Trials\nTo get reliable estimates, we run multiple trials and collect statistics:\n- Mean values\n- Standard deviation\n- Min/Max values\n- Execution time\n\n```python\n\ndef run_monte_carlo_simulation(n, num_trials=100):\n    \"\"\"Run multiple Monte Carlo simulations and analyze results\"\"\"\n    total_estimates = []\n    promising_estimates = []\n    start_time = time.time()\n    \n    for _ in range(num_trials):\n        estimate_result = monte_carlo_estimate(n)\n        total_estimates.append(estimate_result[0])\n        promising_estimates.append(estimate_result[1])\n    \n    execution_time = time.time() - start_time\n    \n    return {\n        'total_nodes': {\n            'mean': mean(total_estimates),\n            'std_dev': stdev(total_estimates),\n            'min': min(total_estimates),\n            'max': max(total_estimates)\n        },\n        'promising_nodes': {\n            'mean': mean(promising_estimates),\n            'std_dev': stdev(promising_estimates),\n            'min': min(promising_estimates),\n            'max': max(promising_estimates)\n        },\n        'execution_time': execution_time,\n        'num_trials': num_trials,\n        'raw_promising': promising_estimates\n    }\n\n```\n\n## Main Execution and Analysis\nHere we:\n1. Run simulations with different trial sizes\n2. Collect and display statistics\n3. Compare with professor's values\n4. Calculate overall averages\n\n```python\n\ndef main():\n    n = 12  # Board size\n    num_trials = [100, 500, 1000]\n    random.seed(123)  # For reproducibility\n    \n    print(f\"\\nMonte Carlo Simulation for {n}-Queens Problem\")\n    print(\"=\" * 60)\n    \n    all_promising_values = []\n    \n    for trials in num_trials:\n        results = run_monte_carlo_simulation(n, trials)\n        print(f\"\\nResults for {trials} trials:\")\n        print(\"\\nTotal Nodes:\")\n        print(f\"Average: {results['total_nodes']['mean']:.2f}\")\n        print(f\"Standard deviation: {results['total_nodes']['std_dev']:.2f}\")\n        print(f\"Min: {results['total_nodes']['min']:.2f}\")\n        print(f\"Max: {results['total_nodes']['max']:.2f}\")\n        \n        print(\"\\nPromising Nodes:\")\n        print(f\"Average: {results['promising_nodes']['mean']:.2f}\")\n        print(f\"Standard deviation: {results['promising_nodes']['std_dev']:.2f}\")\n        print(f\"Min: {results['promising_nodes']['min']:.2f}\")\n        print(f\"Max: {results['promising_nodes']['max']:.2f}\")\n        \n        all_promising_values.extend(results['raw_promising'])\n    \n    # Overall statistics\n    total_runs = sum(num_trials)\n    overall_mean = mean(all_promising_values)\n    overall_std = stdev(all_promising_values)\n    \n    print(\"\\nOverall Statistics:\")\n    print(f\"Total runs: {total_runs}\")\n    print(f\"Overall mean promising nodes: {overall_mean:.2f}\")\n    print(f\"Overall standard deviation: {overall_std:.2f}\")\n    \n    # Compare with professor's value\n    professors_value = 856000\n    percentage_diff = ((overall_mean - professors_value) / professors_value) * 100\n    print(f\"\\nPercentage difference from professor's value: {percentage_diff:.2f}%\")\n\nif __name__ == \"__main__\":\n    main()\n\n```\n\n## Initial Simulation Results\n![Simulation Results](/images/n-simulation-result.png)\n\n\n## Results Analysis\nWhen we run this simulation for n=12:\n1. Our estimates are close to the professor's values:\n   - Professor's value: 8.56 Ã— 10^5\n   - Our estimated value: ~8.70 Ã— 10^5 (within 2% difference)\n2. The standard deviation shows the variability of the Monte Carlo method\n3. Larger numbers of trials generally give more stable results\n\n## Conclusion\nThe Monte Carlo simulation effectively estimates the complexity of the N-Queens problem:\n- Provides good approximations of node counts\n- Much faster than exhaustive counting\n- Helps understand the scale of the problem\n- Results align well with theoretical expectations\n\n## Plots for 4, 8, 12 and 14 Queens problem on a Log scale\n\nAnalysisng the data:\n\n```python\n\n\tdef analyze_complexity(n_values, trials_per_n=1000):\n\t\n\t\"\"\"Analyze time complexity for different values of n\"\"\"\n\t\n\ttotal_nodes_avg = []\n\t\n\tpromising_nodes_avg = []\n\t\n\texecution_times = []\n\t\n\tfor n in n_values:\n\t\n\tstart_time = time.time()\n\t\n\ttrial_totals = []\n\t\n\ttrial_promising = []\n\t\n\tfor _ in range(trials_per_n):\n\t\n\ttotal, promising = monte_carlo_estimate(n)\n\t\n\ttrial_totals.append(total)\n\t\n\ttrial_promising.append(promising)\n\t\n\texec_time = time.time() - start_time\n\t\n\ttotal_nodes_avg.append(mean(trial_totals))\n\t\n\tpromising_nodes_avg.append(mean(trial_promising))\n\t\n\texecution_times.append(exec_time)\n\t\n\tprint(f\"\\nResults for n={n}:\")\n\t\n\tprint(f\"Average Total Nodes: {mean(trial_totals):,.2f}\")\n\t\n\tprint(f\"Average Promising Nodes: {mean(trial_promising):,.2f}\")\n\t\n\tprint(f\"Execution Time: {exec_time:.4f} seconds\")\n\t\n\treturn total_nodes_avg, promising_nodes_avg, execution_times\n```\t\n\t  \nPlotting the graphs:\n\n```python\t\n\tdef plot_complexity_analysis(n_values, total_nodes, promising_nodes, times):\n\t\n\tfig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 6))\n\t\n\t# Plot 1: Nodes vs N (log scale)\n\t\n\tax1.plot(n_values, total_nodes, 'b-o', label='Total Nodes')\n\t\n\tax1.plot(n_values, promising_nodes, 'g-o', label='Promising Nodes')\n\t\n\tax1.set_yscale('log')\n\t\n\tax1.set_title('Growth of Nodes with N\\n(Log Scale)', fontsize=12)\n\t\n\tax1.set_xlabel('N (Board Size)', fontsize=10)\n\t\n\tax1.set_ylabel('Number of Nodes (log scale)', fontsize=10)\n\t\n\tax1.grid(True, alpha=0.3)\n\t\n\tax1.legend()\n\t\n\t# Plot 2: Execution Time vs N\n\t\n\tax2.plot(n_values, times, 'r-o', label='Execution Time')\n\t\n\tax2.set_title('Execution Time vs N', fontsize=12)\n\t\n\tax2.set_xlabel('N (Board Size)', fontsize=10)\n\t\n\tax2.set_ylabel('Time (seconds)', fontsize=10)\n\t\n\tax2.grid(True, alpha=0.3)\n\t\n\tplt.tight_layout()\n\t\n\tplt.show()\n```\n\nMain Function: \n```python\n\tdef main():\n\t\n\trandom.seed(123)\n\t\n\tn_values = [4, 8, 12, 14] # Different board sizes\n\t\n\tprint(\"Analyzing time complexity for N-Queens problem\")\n\t\n\tprint(\"=\" * 60)\n\t\n\ttotal_nodes, promising_nodes, exec_times = analyze_complexity(n_values)\n\t\n\tplot_complexity_analysis(n_values, total_nodes, promising_nodes, exec_times)\n\t\n\t  \n\t\n\tif __name__ == \"__main__\":\n\t\n\tmain()\n\n```\n\n## Complexity Analysis Results\n\n![Complexity Analysis](/images/n-queen-plot.png)\n\n## Code\nFind the complete implementation on [GitHub](https://github.com/Atharva2099/AssignmentsButFun/blob/main/CSC510/Monte%20Carlo%20Simulation%20for%20N-Queens%20Using%20Backtracking%20and%20pruning.ipynb).\n\n---\nGitHub: [@FullMLAlchemist](https://github.com/Atharva2099)\nTwitter: [@Attharave](https://x.com/attharave)\n"},{"slug":"Easy Quizzes","title":"EasyQuizzes AI powered FlashCard Generator","date":"2024-11-07","categories":["RAG","LLM","ChromaDB","Hackathon"],"image":"/images/easy-quizzes.png","summary":"Read this post to learn more...","content":"\n# Automating Study Material Creation with Retrieval-Augmented Generation (RAG)\n\n### Overview\nCreating effective study materials from lengthy notes or research papers can be time-consuming. As someone passionate about machine learning and productivity tools, I developed **EasyQuizzes**, an application that uses Retrieval-Augmented Generation (RAG) to turn notes or PDFs into custom flashcards. This blog walks you through how I implemented RAG and structured the app to automate the process.\n\n### Problem and Motivtion\nCreating flashcards manually from notes often requires significant time and effort. Inspired by my experience with Quizlet, I wanted to streamline this task by building a tool that uses AI to extract key information and generate flashcards instantly.\n\n### Solution Architecture\n\n**1. Setting Up RAG with ChromaDB and LLaMA3**\nTo implement RAG:\n- **LLM Selection**: I used **Meta's LLaMA3.2-3B-preview** via Groq API to ensure low latency and efficient processing.\n- **Embedding and Retrieval**: Using **ChromaDB**, I created vector embeddings for notes, allowing quick retrieval of relevant chunks.\n  \n**2. Core Components**\n**Document Parsing and Chunking:**\nUsing **PyPDF2** and **OCR**, my app converts handwritten or scanned notes into text. Each document is chunked into manageable sections for better LLM performance and stored as vectors in ChromaDB.\n\n**RAG Process**\n\nThe RAG approach includes:\n1. **Retrieving** relevant text chunks based on a prompt.\n2. **Generating** responses by feeding retrieved information to the LLaMA3 model.\n\n**3. Key Code Snippets**\n\n**Document Parsing and Chunk Storage**\n\n```python\n\nimport PyPDF2\n\ndef parse_pdf(file_path):\n    pdf_reader = PyPDF2.PdfFileReader(open(file_path, \"rb\"))\n    text_content = \"\"\n    for page in pdf_reader.pages:\n        text_content += page.extract_text()\n    return text_content\n```\n\n**Flashcard Generation**\n```python\n\ndef generate_flashcards(topic, document_text):\n    retrieved_chunks = chromadb.retrieve(topic)\n    flashcards = []\n    for chunk in retrieved_chunks:\n        question, answer = llm.generate_flashcard(chunk)\n        flashcards.append((question, answer))\n    return flashcards\n```\n\n**4. Key Features and Benefits**\n- **Custom Flashcards in Seconds**: Reduces study prep time by automating question generation.\n- **Accuracy with RAG**: By using retrieval, flashcards focus on relevant information, increasing the quality of study material.\n- **Local Storage and Privacy**: Flashcards and data are stored locally for student privacy and offline access.\n\n## Challenges and Learnings\n1. **Embedding Quality**: Choosing the right embeddings is crucial for retrieving relevant text chunks accurately.\n2. **Latency**: Using the Groq API and an optimized Conda environment helped manage model inference times effectively.\n3. **Chunk Size**: Balancing chunk size was essential to avoid missing context while keeping retrieval efficient.\n\n## Future Improvements\n1. **Multi-language Support**: Given my background in Indic languages, I plan to extend this tool to support content in Hindi and Marathi.\n2. **Mobile App Version**: Allowing flashcard creation on the go for a more seamless study experience.\n\n## Conclusion\nEasyQuizzes demonstrates how retrieval-augmented generation can save time and enhance learning. With AI, students can now spend more time understanding concepts rather than preparing notes.\n\nCheckout EasyQuizzes at : [EasyQuizzes](https://github.com/Atharva2099/EasyQuizzes)\n\n---\nGitHub: [@FullMLAlchemist](https://github.com/Atharva2099)\nTwitter: [@Attharave](https://x.com/attharave)\n\n"},{"slug":"Leetcode 36 Valid Sudoku","title":"Leetcode No.36 Valid Sudoku","date":"2024-11-07","categories":["LeetcodeÂ ","Medium","Data Structure and Algorithms"],"image":"/images/leetcode-36-valid-sudoku.png","summary":"Read this post to learn more...","content":"\n# Understanding the Sudoku Board Validator - LeetCode Solution\n\n## Problem Overview\nLeetCode problem #36 asks us to validate a 9x9 Sudoku board. A valid Sudoku board must satisfy three conditions:\n1. Each row must contain digits 1-9 without repetition\n2. Each column must contain digits 1-9 without repetition\n3. Each 3x3 sub-box must contain digits 1-9 without repetition\n\nNote that empty cells (marked as \".\") are allowed and don't affect validity.\n\n## Solution Approach\nLet's break down the solution into digestible pieces to understand how it efficiently validates a Sudoku board in a single pass.\n\n```python\n\ndef isValidSudoku(self, board: List[List[str]]) -> bool:\n    rows = collections.defaultdict(set)\n    cols = collections.defaultdict(set)\n    sqrs = collections.defaultdict(set)\n```\n\n### Data Structures\nWe use three `defaultdict(set)` to track numbers in:\n- `rows`: Each row of the board\n- `cols`: Each column of the board\n- `sqrs`: Each 3x3 square\n\nUsing `defaultdict(set)` is clever because:\n- It automatically creates an empty set when we access a new key\n- Sets provide O(1) lookup and insertion\n- We don't need to initialize anything manually\n\n### The Main Algorithm\n```python\n\nfor r in range(9):\n    for c in range(9):\n        if board[r][c] == \".\":\n            continue\n```\nWe iterate through each cell. If it's empty (\".\"), we skip it.\n\n```python\n\nif (board[r][c] in rows[r] or\n    board[r][c] in cols[c] or \n    board[r][c] in sqrs[(r//3,c//3)]):\n    return False\n```\n\nFor each number, we check three conditions:\n1. Is it already in the current row?\n2. Is it already in the current column?\n3. Is it already in the current 3x3 square?\n\nThe expression `(r//3,c//3)` is particularly clever:\n- It maps the 9x9 grid coordinates to 3x3 square coordinates\n- For example:\n  - Cell (0,0) maps to square (0,0)\n  - Cell (1,1) maps to square (0,0)\n  - Cell (3,3) maps to square (1,1)\n\n```python\n\nrows[r].add(board[r][c])\ncols[c].add(board[r][c])\nsqrs[(r//3,c//3)].add(board[r][c])\n```\n\nIf all checks pass, we:\n1. Add the number to its row set\n2. Add it to its column set\n3. Add it to its 3x3 square set\n\nIf we complete the entire board without finding any duplicates, return `True`.\n\n## Time and Space Complexity\n- Time Complexity: O(1)\n  - We always process exactly 81 cells (9x9 board)\n  - Each cell operation is O(1) due to set operations\n- Space Complexity: O(1)\n  - We store at most 9 numbers in each set\n  - We have a fixed number of sets (9 rows + 9 columns + 9 squares)\n\n## Advantages of this Solution\n1. **Single Pass**: We only need to traverse the board once\n2. **Early Exit**: Returns `False` as soon as an invalid state is detected\n3. **Clean Code**: Using `defaultdict(set)` makes the code concise and readable\n4. **Efficient Lookups**: Set operations are O(1)\n\n## Common Pitfalls to Avoid\n1. Don't forget to check empty cells (\".\") and skip them\n2. Remember that valid numbers are strings (\"1\" to \"9\"), not integers\n3. The 3x3 square calculation `(r//3,c//3)` must use integer division\n\n## Conclusion\nThis solution demonstrates how proper data structure choice (using sets) and clever coordinate mapping (for 3x3 squares) can lead to a clean and efficient solution. While there are other ways to solve this problem, this approach provides an excellent balance of readability and performance.\n\n---\nGitHub: [@FullMLAlchemist](https://github.com/Atharva2099)\nTwitter: [@Attharave](https://x.com/attharave)"},{"slug":"Building a Simple Shell in C","title":"Building a Shell in C","date":"2024-10-28","categories":["Programming","C","Operating Systems"],"image":"/images/building-a-simple-shell-in-c.png","summary":"Read this post to learn more...","content":"\n# Building a shell with pipes in C \n\nCommand-line shells are an essential part of operating systems, allowing users to interact with the system via commands. While modern operating systems have powerful, feature-rich shells, understanding how they work at a low level provides crucial insight into process management, input/output operations, and more. In this post, weâ€™ll take a closer look at building a simple shell in C, particularly focusing on three key phases: **Read**, **Parse**, and **Execute**.\n\n<div class=\"video-container\">\n  <iframe\n    width=\"100%\"\n    height=\"500\"\n    src=\"https://www.youtube.com/embed/2J7g3KcZJ3I\"\n    title=\"Building a Simple Shell in C\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen>\n  </iframe>\n</div>\n\n### 1. The Shell Process Lifecycle\n\nThe shell can be broken down into three distinct phases:\n\n- **Read Phase**: The shell reads the userâ€™s command.\n\n- **Parse Phase**: The shell breaks the command into individual tokens (like command and arguments) and prepares for execution.\n\n- **Execute Phase**: The shell forks a new process to execute the command.\n\nLetâ€™s explore each phase in more detail.\n\n-----------\n### 2. **Read Phase**\n\nIn the **Read Phase**, the shell waits for user input. This input could be a simple command like `ls` or something more complex, involving pipes (`|`) and redirection (`>`, `<`). The input is typically read as a single string, which the shell will process further.\n\nIn C, this can be achieved using functions like `fgets()` or `read()` to capture input from the user.\n\n#### Example:\n\n```c\n\nchar input[1024];\n\nprintf(\"shell> \");\n\nfgets(input, sizeof(input), stdin);\n\n```\n\nThis code snippet captures user input of up to 1024 characters. Once the input is read, the shell proceeds to the **Parse Phase**.\n\n-----\n### 3. **Parse Phase**\n\nThe **Parse Phase** involves breaking down the userâ€™s input into smaller components, known as **tokens**. These tokens are typically the command (like `ls`) and its arguments (like `-l`, `| grep .c`).\n\nIn C, functions like `strtok()` are useful for breaking the input string into tokens based on delimiters (like spaces or pipe symbols).\n\n#### Example:\n\n```c\n\nchar *token;\n\ntoken = strtok(input, \" \\n\");\n\nwhile (token != NULL) {\n\nÂ Â Â  printf(\"%s\\n\", token);Â  // Process each token\n\nÂ Â Â  token = strtok(NULL, \" \\n\");\n\n}\n\n```\n\nThis will break the userâ€™s input into individual tokens. For example, if the user types `ls -l | grep .c`, the tokens will be `ls`, `-l`, `|`, and `grep .c`.\n\nThe shell needs to handle each of these tokens appropriately, determining what the user wants to achieve (e.g., if thereâ€™s a pipe, we need to split the command into two processes).\n\n--------\n### 4. **Execute Phase**\n\nFinally, the **Execute Phase** is where the shell runs the command. In most cases, this involves creating a new child process using `fork()`, and then using `execvp()` or similar system calls to replace the child processâ€™s memory with the new commandâ€™s memory.\n\nFor commands involving pipes or redirection, this phase becomes slightly more complex, as the shell needs to manage file descriptors and direct output from one process to another.\n\n#### Example:\n\n```c\n\npid_t pid = fork();\n\nif (pid == 0) {\n\nÂ Â Â  // Child process\n\nÂ Â Â  execvp(command[0], command);\n\nÂ Â Â  perror(\"execvp\");\n\nÂ Â Â  exit(EXIT_FAILURE);\n\n} else if (pid > 0) {\n\nÂ Â Â  // Parent process\n\nÂ Â Â  wait(NULL);\n\n} else {\n\nÂ Â Â  perror(\"fork\");\n\nÂ Â Â  exit(EXIT_FAILURE);\n\n}\n\n```\n\nThis simple fork/exec pattern allows the shell to run commands. The parent process waits for the child to complete using `wait()`, ensuring that commands are executed sequentially unless the user requests background execution.\n\n---\n\n### 5. **Advanced Features**\n\nBuilding a fully functional shell also requires adding advanced features like:\n\n- **Piping**: Sending the output of one command as input to another (e.g., `ls | grep .c`).\n\n- **Redirection**: Redirecting output to a file or input from a file (e.g., `ls > output.txt`).\n\n- **Signal Handling**: Handling interrupts (e.g., `Ctrl+C`) to terminate running processes or commands.\n\nWhile these features add complexity, they are also what make a shell useful. Understanding the basics of process control and inter-process communication (pipes) will help you implement these features.\n\n---\n\n### Conclusion\n\nBuilding a shell from scratch is an excellent way to learn about process management, system calls, and low-level programming in C. By breaking the problem down into the **Read**, **Parse**, and **Execute** phases, you can focus on each aspect individually and build up to more complex features like piping and redirection.\n\nOnce you understand how these phases interact, you can experiment with adding more functionality and customization to your shell. And who knows? You might end up building a command-line interface that fits your workflow better than existing ones.\n\n---\nGitHub: [@FullMLAlchemist](https://github.com/Atharva2099)\nTwitter: [@Attharave](https://x.com/attharave)\n"}],"topCategories":["LLM","Programming","C","Operating Systems","RAG","ChromaDB","Hackathon","React","LeetcodeÂ ","Medium"]},"__N_SSG":true}