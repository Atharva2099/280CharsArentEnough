{"pageProps":{"postData":{"slug":"Leetcode 36 Valid Sudoku","htmlContent":"<h1>Understanding the Sudoku Board Validator - LeetCode Solution</h1>\n<h2>Problem Overview</h2>\n<p>LeetCode problem #36 asks us to validate a 9x9 Sudoku board. A valid Sudoku board must satisfy three conditions:</p>\n<ol>\n<li>Each row must contain digits 1-9 without repetition</li>\n<li>Each column must contain digits 1-9 without repetition</li>\n<li>Each 3x3 sub-box must contain digits 1-9 without repetition</li>\n</ol>\n<p>Note that empty cells (marked as “.”) are allowed and don’t affect validity.</p>\n<h2>Solution Approach</h2>\n<p>Let’s break down the solution into digestible pieces to understand how it efficiently validates a Sudoku board in a single pass.</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-keyword\">def</span> <span class=\"hljs-title function_\">isValidSudoku</span>(<span class=\"hljs-params\">self, board: <span class=\"hljs-type\">List</span>[<span class=\"hljs-type\">List</span>[<span class=\"hljs-built_in\">str</span>]]</span>) -&gt; <span class=\"hljs-built_in\">bool</span>:\n    rows = collections.defaultdict(<span class=\"hljs-built_in\">set</span>)\n    cols = collections.defaultdict(<span class=\"hljs-built_in\">set</span>)\n    sqrs = collections.defaultdict(<span class=\"hljs-built_in\">set</span>)\n</code></pre>\n<h3>Data Structures</h3>\n<p>We use three <code>defaultdict(set)</code> to track numbers in:</p>\n<ul>\n<li><code>rows</code>: Each row of the board</li>\n<li><code>cols</code>: Each column of the board</li>\n<li><code>sqrs</code>: Each 3x3 square</li>\n</ul>\n<p>Using <code>defaultdict(set)</code> is clever because:</p>\n<ul>\n<li>It automatically creates an empty set when we access a new key</li>\n<li>Sets provide O(1) lookup and insertion</li>\n<li>We don’t need to initialize anything manually</li>\n</ul>\n<h3>The Main Algorithm</h3>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-keyword\">for</span> r <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">9</span>):\n    <span class=\"hljs-keyword\">for</span> c <span class=\"hljs-keyword\">in</span> <span class=\"hljs-built_in\">range</span>(<span class=\"hljs-number\">9</span>):\n        <span class=\"hljs-keyword\">if</span> board[r][c] == <span class=\"hljs-string\">&quot;.&quot;</span>:\n            <span class=\"hljs-keyword\">continue</span>\n</code></pre>\n<p>We iterate through each cell. If it’s empty (“.”), we skip it.</p>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-keyword\">if</span> (board[r][c] <span class=\"hljs-keyword\">in</span> rows[r] <span class=\"hljs-keyword\">or</span>\n    board[r][c] <span class=\"hljs-keyword\">in</span> cols[c] <span class=\"hljs-keyword\">or</span> \n    board[r][c] <span class=\"hljs-keyword\">in</span> sqrs[(r//<span class=\"hljs-number\">3</span>,c//<span class=\"hljs-number\">3</span>)]):\n    <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">False</span>\n</code></pre>\n<p>For each number, we check three conditions:</p>\n<ol>\n<li>Is it already in the current row?</li>\n<li>Is it already in the current column?</li>\n<li>Is it already in the current 3x3 square?</li>\n</ol>\n<p>The expression <code>(r//3,c//3)</code> is particularly clever:</p>\n<ul>\n<li>It maps the 9x9 grid coordinates to 3x3 square coordinates</li>\n<li>For example:\n<ul>\n<li>Cell (0,0) maps to square (0,0)</li>\n<li>Cell (1,1) maps to square (0,0)</li>\n<li>Cell (3,3) maps to square (1,1)</li>\n</ul>\n</li>\n</ul>\n<pre class=\"hljs\"><code>\nrows[r].add(board[r][c])\ncols[c].add(board[r][c])\nsqrs[(r//<span class=\"hljs-number\">3</span>,c//<span class=\"hljs-number\">3</span>)].add(board[r][c])\n</code></pre>\n<p>If all checks pass, we:</p>\n<ol>\n<li>Add the number to its row set</li>\n<li>Add it to its column set</li>\n<li>Add it to its 3x3 square set</li>\n</ol>\n<p>If we complete the entire board without finding any duplicates, return <code>True</code>.</p>\n<h2>Time and Space Complexity</h2>\n<ul>\n<li>Time Complexity: O(1)\n<ul>\n<li>We always process exactly 81 cells (9x9 board)</li>\n<li>Each cell operation is O(1) due to set operations</li>\n</ul>\n</li>\n<li>Space Complexity: O(1)\n<ul>\n<li>We store at most 9 numbers in each set</li>\n<li>We have a fixed number of sets (9 rows + 9 columns + 9 squares)</li>\n</ul>\n</li>\n</ul>\n<h2>Advantages of this Solution</h2>\n<ol>\n<li><strong>Single Pass</strong>: We only need to traverse the board once</li>\n<li><strong>Early Exit</strong>: Returns <code>False</code> as soon as an invalid state is detected</li>\n<li><strong>Clean Code</strong>: Using <code>defaultdict(set)</code> makes the code concise and readable</li>\n<li><strong>Efficient Lookups</strong>: Set operations are O(1)</li>\n</ol>\n<h2>Common Pitfalls to Avoid</h2>\n<ol>\n<li>Don’t forget to check empty cells (“.”) and skip them</li>\n<li>Remember that valid numbers are strings (“1” to “9”), not integers</li>\n<li>The 3x3 square calculation <code>(r//3,c//3)</code> must use integer division</li>\n</ol>\n<h2>Conclusion</h2>\n<p>This solution demonstrates how proper data structure choice (using sets) and clever coordinate mapping (for 3x3 squares) can lead to a clean and efficient solution. While there are other ways to solve this problem, this approach provides an excellent balance of readability and performance.</p>\n<hr>\n<p>GitHub: <a href=\"https://github.com/Atharva2099\">@FullMLAlchemist</a>\nTwitter: <a href=\"https://x.com/attharave\">@Attharave</a></p>\n","title":"Leetcode No.36 Valid Sudoku","date":"2024-11-07","categories":["Leetcode ","Medium","Data Structure and Algorithms"],"image":"/images/leetcode-no-36-valid-sudoku.png","summary":""}},"__N_SSG":true}