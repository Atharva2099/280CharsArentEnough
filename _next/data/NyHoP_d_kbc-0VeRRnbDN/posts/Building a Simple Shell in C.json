{"pageProps":{"postData":{"slug":"Building a Simple Shell in C","htmlContent":"<h1>Building a shell with pipes in C</h1>\n<p>Command-line shells are an essential part of operating systems, allowing users to interact with the system via commands. While modern operating systems have powerful, feature-rich shells, understanding how they work at a low level provides crucial insight into process management, input/output operations, and more. In this post, we’ll take a closer look at building a simple shell in C, particularly focusing on three key phases: <strong>Read</strong>, <strong>Parse</strong>, and <strong>Execute</strong>.</p>\n<div class=\"video-container\">\n  <iframe\n    width=\"100%\"\n    height=\"500\"\n    src=\"https://www.youtube.com/embed/2J7g3KcZJ3I\"\n    title=\"Building a Simple Shell in C\"\n    frameborder=\"0\"\n    allow=\"accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture\"\n    allowfullscreen>\n  </iframe>\n</div>\n<h3>1. The Shell Process Lifecycle</h3>\n<p>The shell can be broken down into three distinct phases:</p>\n<ul>\n<li>\n<p><strong>Read Phase</strong>: The shell reads the user’s command.</p>\n</li>\n<li>\n<p><strong>Parse Phase</strong>: The shell breaks the command into individual tokens (like command and arguments) and prepares for execution.</p>\n</li>\n<li>\n<p><strong>Execute Phase</strong>: The shell forks a new process to execute the command.</p>\n</li>\n</ul>\n<p>Let’s explore each phase in more detail.</p>\n<hr>\n<h3>2. <strong>Read Phase</strong></h3>\n<p>In the <strong>Read Phase</strong>, the shell waits for user input. This input could be a simple command like <code>ls</code> or something more complex, involving pipes (<code>|</code>) and redirection (<code>&gt;</code>, <code>&lt;</code>). The input is typically read as a single string, which the shell will process further.</p>\n<p>In C, this can be achieved using functions like <code>fgets()</code> or <code>read()</code> to capture input from the user.</p>\n<h4>Example:</h4>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-type\">char</span> input[<span class=\"hljs-number\">1024</span>];\n\n<span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;shell&gt; &quot;</span>);\n\nfgets(input, <span class=\"hljs-keyword\">sizeof</span>(input), <span class=\"hljs-built_in\">stdin</span>);\n\n</code></pre>\n<p>This code snippet captures user input of up to 1024 characters. Once the input is read, the shell proceeds to the <strong>Parse Phase</strong>.</p>\n<hr>\n<h3>3. <strong>Parse Phase</strong></h3>\n<p>The <strong>Parse Phase</strong> involves breaking down the user’s input into smaller components, known as <strong>tokens</strong>. These tokens are typically the command (like <code>ls</code>) and its arguments (like <code>-l</code>, <code>| grep .c</code>).</p>\n<p>In C, functions like <code>strtok()</code> are useful for breaking the input string into tokens based on delimiters (like spaces or pipe symbols).</p>\n<h4>Example:</h4>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-type\">char</span> *token;\n\ntoken = strtok(input, <span class=\"hljs-string\">&quot; \\n&quot;</span>);\n\n<span class=\"hljs-keyword\">while</span> (token != <span class=\"hljs-literal\">NULL</span>) {\n\n    <span class=\"hljs-built_in\">printf</span>(<span class=\"hljs-string\">&quot;%s\\n&quot;</span>, token);  <span class=\"hljs-comment\">// Process each token</span>\n\n    token = strtok(<span class=\"hljs-literal\">NULL</span>, <span class=\"hljs-string\">&quot; \\n&quot;</span>);\n\n}\n\n</code></pre>\n<p>This will break the user’s input into individual tokens. For example, if the user types <code>ls -l | grep .c</code>, the tokens will be <code>ls</code>, <code>-l</code>, <code>|</code>, and <code>grep .c</code>.</p>\n<p>The shell needs to handle each of these tokens appropriately, determining what the user wants to achieve (e.g., if there’s a pipe, we need to split the command into two processes).</p>\n<hr>\n<h3>4. <strong>Execute Phase</strong></h3>\n<p>Finally, the <strong>Execute Phase</strong> is where the shell runs the command. In most cases, this involves creating a new child process using <code>fork()</code>, and then using <code>execvp()</code> or similar system calls to replace the child process’s memory with the new command’s memory.</p>\n<p>For commands involving pipes or redirection, this phase becomes slightly more complex, as the shell needs to manage file descriptors and direct output from one process to another.</p>\n<h4>Example:</h4>\n<pre class=\"hljs\"><code>\n<span class=\"hljs-type\">pid_t</span> pid = fork();\n\n<span class=\"hljs-keyword\">if</span> (pid == <span class=\"hljs-number\">0</span>) {\n\n    <span class=\"hljs-comment\">// Child process</span>\n\n    execvp(command[<span class=\"hljs-number\">0</span>], command);\n\n    perror(<span class=\"hljs-string\">&quot;execvp&quot;</span>);\n\n    <span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (pid &gt; <span class=\"hljs-number\">0</span>) {\n\n    <span class=\"hljs-comment\">// Parent process</span>\n\n    wait(<span class=\"hljs-literal\">NULL</span>);\n\n} <span class=\"hljs-keyword\">else</span> {\n\n    perror(<span class=\"hljs-string\">&quot;fork&quot;</span>);\n\n    <span class=\"hljs-built_in\">exit</span>(EXIT_FAILURE);\n\n}\n\n</code></pre>\n<p>This simple fork/exec pattern allows the shell to run commands. The parent process waits for the child to complete using <code>wait()</code>, ensuring that commands are executed sequentially unless the user requests background execution.</p>\n<hr>\n<h3>5. <strong>Advanced Features</strong></h3>\n<p>Building a fully functional shell also requires adding advanced features like:</p>\n<ul>\n<li>\n<p><strong>Piping</strong>: Sending the output of one command as input to another (e.g., <code>ls | grep .c</code>).</p>\n</li>\n<li>\n<p><strong>Redirection</strong>: Redirecting output to a file or input from a file (e.g., <code>ls &gt; output.txt</code>).</p>\n</li>\n<li>\n<p><strong>Signal Handling</strong>: Handling interrupts (e.g., <code>Ctrl+C</code>) to terminate running processes or commands.</p>\n</li>\n</ul>\n<p>While these features add complexity, they are also what make a shell useful. Understanding the basics of process control and inter-process communication (pipes) will help you implement these features.</p>\n<hr>\n<h3>Conclusion</h3>\n<p>Building a shell from scratch is an excellent way to learn about process management, system calls, and low-level programming in C. By breaking the problem down into the <strong>Read</strong>, <strong>Parse</strong>, and <strong>Execute</strong> phases, you can focus on each aspect individually and build up to more complex features like piping and redirection.</p>\n<p>Once you understand how these phases interact, you can experiment with adding more functionality and customization to your shell. And who knows? You might end up building a command-line interface that fits your workflow better than existing ones.</p>\n<hr>\n<p>GitHub: <a href=\"https://github.com/Atharva2099\">@FullMLAlchemist</a>\nTwitter: <a href=\"https://x.com/attharave\">@Attharave</a></p>\n","title":"Building a Shell in C","date":"2024-10-28","categories":["Programming","C","Operating Systems"],"image":"/images/building-a-shell-in-c.png","summary":""}},"__N_SSG":true}